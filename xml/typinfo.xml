<?xml version="1.0" encoding="ISO-8859-1"?>
<fpdoc-descriptions>
<!--  

   This file is part of the FPC documentation. 
   Copyright (C) 1997, by Michael Van Canneyt 
 
   The FPC documentation is free text; you can redistribute it and/or 
   modify it under the terms of the GNU Library General Public License as 
   published by the Free Software Foundation; either version 2 of the 
   License, or (at your option) any later version. 
 
   The FPC Documentation is distributed in the hope that it will be useful, 
   but WITHOUT ANY WARRANTY; without even the implied warranty of 
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
   Library General Public License for more details. 
 
   You should have received a copy of the GNU Library General Public 
   License along with the FPC documentation; see the file COPYING.LIB.  If not, 
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, 
   Boston, MA 02111-1307, USA. 
 -->
<package name="rtl">
<module name="typinfo">
<short>Access Run-Time Type Information (RTTI)</short>
<!-- \FPCexampledir{typinfex} -->
<descr>
<p>
The <file>TypInfo</file> unit contains many routines which can be used for
the querying of the Run-Time Type Information (RTTI) which is generated
by the compiler for classes that are compiled under the <var>{$M+}</var>
switch. This information can be used to retrieve or set property values
for published properties for totally unknown classes. In particular, it
can be used to stream classes. The <var>TPersistent</var> class in the 
<file>Classes</file> unit is compiled in the <var>{$M+}</var> state and serves
as the base class for all classes that need to be streamed.
</p>
<p>
The unit should be compatible to the Delphi  unit with the same name. 
</p>
<p>
The examples in this chapter use a <file>rttiobj</file> auxiliary unit, 
which contains an object that has a published property for all supported
types. It also contains some auxiliary routines and definitions. This 
unit is included in the documentation sources, in the directory
<file>typinfex</file>.
</p>
</descr>

<topic name="ExaminePropInfo">
<short>Examining published property information</short>
<descr>
<p>
Functions for retrieving or examining property information
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="FindPropInfo"/></td><td>Getting property type information, With error checking.</td></tr>
<tr><td><link id="GetPropInfo"/></td><td>Getting property type information, No error checking.</td></tr>
<tr><td><link id="GetPropInfos"/></td><td>Find property information of a certain kind</td></tr>
<tr><td><link id="GetObjectPropClass"/></td><td>Return the declared class of an object property</td></tr>
<tr><td><link id="GetPropList"/></td><td>Get a list of all published properties</td></tr>
<tr><td><link id="IsPublishedProp"/></td><td>Is a property published</td></tr>
<tr><td><link id="IsStoredProp"/></td><td>Is a property stored</td></tr>
<tr><td><link id="PropIsType"/></td><td>Is a property of a certain kind</td></tr>
<tr><td><link id="PropType"/></td><td>Return the type of a property</td></tr>
</table>
</descr>
</topic>

<topic name="ManipulatePropValues">
<short>Getting or setting property values</short>
<descr>
<p>
Functions to set or set a property's value.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="GetEnumProp"/></td><td>Return the value of an enumerated type property</td></tr>
<tr><td><link id="GetFloatProp"/></td><td>Return the value of a float property</td></tr>
<tr><td><link id="GetInt64Prop"/></td><td>Return the value of an Int64 property</td></tr>
<tr><td><link id="GetMethodProp"/></td><td>Return the value of a procedural type property</td></tr>
<tr><td><link id="GetObjectProp"/></td><td>Return the value of an object property</td></tr>
<tr><td><link id="GetOrdProp"/></td><td>Return the value of an ordinal type property</td></tr>
<tr><td><link id="GetPropValue"/></td><td>Return the value of a property as a variant</td></tr>
<tr><td><link id="GetSetProp"/></td><td>Return the value of a set property</td></tr>
<tr><td><link id="GetStrProp"/></td><td>Return the value of a string property</td></tr>
<tr><td><link id="GetWideStrProp"/></td><td>Return the value of a widestring property</td></tr>
<tr><td><link id="GetVariantProp"/></td><td>Return the value of a variant property</td></tr>
<tr><td><link id="SetEnumProp"/></td><td>Set the value of an enumerated type property</td></tr>
<tr><td><link id="SetFloatProp"/></td><td>Set the value of a float property</td></tr>
<tr><td><link id="SetInt64Prop"/></td><td>Set the value of an Int64 property</td></tr>
<tr><td><link id="SetMethodProp"/></td><td>Set the value of a procedural type property</td></tr>
<tr><td><link id="SetObjectProp"/></td><td>Set the value of an object property</td></tr>
<tr><td><link id="SetOrdProp"/></td><td>Set the value of an ordinal type property</td></tr>
<tr><td><link id="SetPropValue"/></td><td>Set the value of a property through a variant</td></tr>
<tr><td><link id="SetSetProp"/></td><td>Set the value of a set property</td></tr>
<tr><td><link id="SetStrProp"/></td><td>Set the value of a string property</td></tr>
<tr><td><link id="SetWideStrProp"/></td><td>Set the value of a widestring property</td></tr>
<tr><td><link id="SetVariantProp"/></td><td>Set the value of a variant property</td></tr>
</table>
</descr>
</topic>

<topic name="AuxiliaryTypinfo">
<short>Auxiliary functions</short>
<descr>
<p>
Other typinfo related functions.
</p>
<table>
<th><td>Name</td><td>Description</td></th>
<tr><td><link id="GetEnumName"/></td><td>Get an enumerated type element name</td></tr>
<tr><td><link id="GetEnumValue"/></td><td>Get ordinal number of an enumerated type, based on the name.</td></tr>
<tr><td><link id="GetEnumNameCount"/></td><td>Get number of elements in an enumerated type.</td></tr>
<tr><td><link id="GetTypeData"/></td><td>Skip type name and return a pointer to the type data</td></tr>
<tr><td><link id="SetToString"/></td><td>Convert a set to its string representation</td></tr>
<tr><td><link id="StringToSet"/></td><td>Convert a string representation of a set to a set</td></tr>
</table>
</descr>
</topic>


<element name="BooleanIdents">
<short>Names for boolean values</short>
</element>

<element name="DotSep">
<short>Name separator character</short>
</element>

<element name="ptField">
<short>Property access directly from field</short>
</element>

<element name="ptStatic">
<short>Property access via static method</short>
</element>

<element name="ptVirtual">
<short>Property access via virtual method</short>
</element>

<element name="ptConst">
<short>Constant used in access method</short>
</element>

<element name="tkAny">
<short>Any property type</short>
</element>

<element name="tkMethods">
<short>Only method properties. (event handlers)</short>
</element>

<element name="tkProperties">
<short>Real properties. (not methods)</short>
</element>

<element name="PShortString">
<short>Pointer to shortstring</short>
</element>

<element name="PByte">
<short>Pointer to byte</short>
</element>

<element name="PWord">
<short>Pointer to Word</short>
</element>

<element name="PLongint">
<short>Pointer to longint</short>
</element>

<element name="PBoolean">
<short>Pointer to boolean</short>
</element>

<element name="PSingle">
<short>Pointer to single</short>
</element>

<element name="PDouble">
<short>Pointer to double</short>
</element>

<element name="PExtended">
<short>Pointer to extended</short>
</element>

<element name="PComp">
<short>Pointer to comp</short>
</element>

<element name="PFixed16">
<short>Pointer to Fixed16</short>
</element>

<element name="Variant">
<short>Dummy type. Do not use.</short>
</element>

<element name="TTypeKind">
<short>Type of a property.</short>
<descr>
<var>TTypeKind</var> was moved to the system unit, see <link id="#rtl.system.TTypeKind"/>
</descr>
<seealso>
<link id="#rtl.system.TTypeKind"/>  
</seealso>
</element>

<element name="tkString">
<short>Alias for the <var>tsSString</var> enumeration value</short>
</element>


<element name="tkUnknown">
<short>Unknown property type.</short>
</element>

<element name="tkInteger">
<short>Integer property.</short>
</element>

<element name="tkChar">
<short>Char property.</short>
</element>

<element name="tkEnumeration">
<short>Enumeration type property.</short>
</element>

<element name="tkFloat">
<short>Float property.</short>
</element>

<element name="tkSet">
<short>Set property.</short>
</element>

<element name="tkMethod">
<short>Method property.</short>
</element>

<element name="tkSString">
<short>Shortstring property.</short>
</element>

<element name="tkLString">
<short>Longstring property.</short>
</element>

<element name="tkAString">
<short>Ansistring property.</short>
</element>

<element name="tkWString">
<short>Widestring property.</short>
</element>

<element name="tkVariant">
<short>Variant property.</short>
</element>

<element name="tkArray">
<short>Array property.</short>
</element>

<element name="tkRecord">
<short>Record property.</short>
</element>

<element name="tkInterface">
<short>Interface property.</short>
</element>

<element name="tkClass">
<short>Class property.</short>
</element>

<element name="tkObject">
<short>Object property.</short>
</element>

<element name="tkWChar">
<short>Widechar property.</short>
</element>

<element name="tkBool">
<short>Boolean property.</short>
</element>

<element name="tkInt64">
<short>Int64 property.</short>
</element>

<element name="tkQWord">
<short>QWord property.</short>
</element>

<element name="tkDynArray">
<short>Dynamical array property.</short>
</element>

<element name="tkInterfaceRaw">
<short>Raw interface property.</short>
</element>

<element name="TOrdType">
<short>Size and sign of ordinal property type.</short>
<descr>
If the property is and ordinal type, then <var>TOrdType</var> determines
the size and sign of the ordinal type:
</descr>
</element>

<element name="TOrdType.otSByte">
<short>Signed byte</short>
</element>

<element name="TOrdType.otUByte">
<short>Unsigned byte</short>
</element>

<element name="TOrdType.otSWord">
<short>Signed word</short>
</element>

<element name="TOrdType.otUWord">
<short>Unsigned word</short>
</element>

<element name="TOrdType.otSLong">
<short>Signed longint</short>
</element>

<element name="TOrdType.otULong">
<short>Unsigned longing (Cardinal)</short>
</element>

<element name="TOrdType">
<short>Alias for <link id="#rtl.typinfo.TordType">TOrdType</link>.</short>
<descr>
If the property is and ordinal type, then <var>TOrdType</var> determines
the size and sign of the ordinal type:
</descr>
</element>

<element name="TOrdType.otSByte">
<short>Signed byte</short>
</element>

<element name="TOrdType.otUByte">
<short>Unsigned byte</short>
</element>

<element name="TOrdType.otSWord">
<short>Signed word</short>
</element>

<element name="TOrdType.otUWord">
<short>Unsigned word</short>
</element>

<element name="TOrdType.otSLong">
<short>Signed longint</short>
</element>

<element name="TOrdType.otULong">
<short>Unsigned longing (Cardinal)</short>
</element>

<element name="TFloatType">
<short>The size of a float type.</short>
</element>

<element name="TFloatType.ftSingle">
<short>Single-sized float</short>
</element>

<element name="TFloatType.ftDouble">
<short>Double-sized float</short>
</element>

<element name="TFloatType.ftExtended">
<short>Extended-size float</short>
</element>

<element name="TFloatType.ftComp">
<short>Comp-type float</short>
</element>

<element name="TFloatType.ftCurr">
<short>Currency-type float</short>
</element>

<element name="TFloatType.ftFixed16">
<short>16-bit float type</short>
</element>

<element name="TFloatType.ftFixed32">
<short>32-bit float type.</short>
</element>

<element name="TMethodKind">
<short>Method type description</short>
</element>

<element name="TMethodKind.mkProcedure">
<short>Procedure method.</short>
</element>

<element name="TMethodKind.mkFunction">
<short>Function method</short>
</element>

<element name="TMethodKind.mkConstructor">
<short>Class constructor</short>
</element>

<element name="TMethodKind.mkDestructor">
<short>Class Destructor</short>
</element>

<element name="TMethodKind.mkClassProcedure">
<short>Class procedure</short>
</element>

<element name="TMethodKind.mkClassFunction">
<short>Class function</short>
</element>

<element name="TParamFlags">
<short>The kind of parameter for a method</short>
</element>

<element name="TParamFlags.pfVar">
<short>Parameter passed by reference</short>
</element>

<element name="TParamFlags.pfConst">
<short>Parameter passed as const (reference)</short>
</element>

<element name="TParamFlags.pfArray">
<short>Array parameter</short>
</element>

<element name="TParamFlags.pfAddress">
<short>Address is passed</short>
</element>

<element name="TParamFlags.pfReference">
<short>Reference passed</short>
</element>

<element name="TParamFlags.pfOut">
<short>Out (by reference)</short>
</element>

<element name="TIntfFlag">
<short>Type of interface.</short>
</element>

<element name="TIntfFlags">
<short>Set of <link id="TIntfFlag"/>.</short>
</element>

<element name="TIntfFlagsBase">
<short>Set of <link id="TIntfFlag"/>.</short>
</element>

<element name="TIntfFlag.ifHasGuid">
<short>Interface has GUID identifier</short>
</element>

<element name="TIntfFlag.ifDispInterface">
<short>Interface is a dual dispatch interface</short>
</element>

<element name="TIntfFlag.ifDispatch">
<short>Interface is a dispatch interface</short>
</element>

<element name="TTypeKinds">
<short>Set of <link id="TTypeKind"/> enumeration.</short>
</element>

<element name="TTypeInfo">
<short>Type information record</short>
<descr>
<p>
The <var>TypeInfo</var> function returns a pointer to a <var>TTypeInfo</var>
record.
</p>
<p>
Note that the Name field is stored with as much bytes as needed to store the name,
it is not padded to 255 characters. 
The type data immediately follows the <var>TTypeInfo</var> record as a <link
id="TTypeData"/> record.
</p>
</descr>
</element>

<element name="TTypeInfo.Name">
<short>Type name</short>
</element>

<element name="TTypeInfo.Kind">
<short>Type kind</short>
</element>

<element name="PTypeInfo">
<short>Pointer to <link id="TTypeInfo"/> record</short>
</element>
<element name="PPTypeInfo">
<short>Pointer to <link id="PTypeInfo"/> pointer</short>
</element>

<element name="PTypeData">
<short>Pointer to <link id="TTypeData"/> record.</short>
</element>

<element name="TTypeData">
<short>Class properties type data record.</short>
<descr>
<p>
If the typeinfo kind is <var>tkClass</var>, then the property 
information follows the <var>UnitName</var> string, as an array of <link
id="TPropInfo"/> records.
</p>
</descr>
</element>

<element name="TPropData">
<short>Property data record</short>
<descr>
The <var>TPropData</var> record is not used, but is provided for completeness and
compatibility with Delphi.
</descr>
</element>

<element name="PPropInfo">
<short>Pointer to <link id="TPropInfo"/> record</short>
</element>

<element name="TPropInfo">
<short>Record describing one published property of a class</short>
<descr>
<p>
The <var>TPropInfo</var> record describes one published property of a class.
The property information of a class are stored as an array of
<var>TPropInfo</var> records.
</p>
<p>
The <var>Name</var> field is stored not with 255 characters, but with just as many characters
as required to store the name.
</p>
</descr>
</element>

<element name="TPropInfo.PropType">
<short>Property type</short>
</element>
<element name="TPropInfo.GetProc">
<short>Read handler</short>
</element>
<element name="TPropInfo.SetProc">
<short>Write handler</short>
</element>
<element name="TPropInfo.StoredProc">
<short>Procedure pointer for stored keyword.</short>
</element>
<element name="TPropInfo.Index">
<short>Index for array properties</short>
</element>
<element name="TPropInfo.Default">
<short>Default value</short>
</element>
<element name="TPropInfo.NameIndex">
<short>Index for indexed properties</short>
</element>
<element name="TPropInfo.PropProcs">
<short>Flags describing property procedures.</short>
</element>
<element name="TPropInfo.Name">
<short>Property name</short>
</element>

<element name="TProcInfoProc">
<short>Property info callback method</short>
</element>

<element name="TPropList">
<short>Array of property information pointers</short>
</element>

<element name="PPropList">
<short>Pointer to <link id="TPropList"/></short>
</element>

<element name="EPropertyError">
<short>Exception raised in case of an error in one of the functions.</short>
</element>

<element name="FindPropInfo">
<short>Return property information by property name.</short>
<descr>
<p>
<var>FindPropInfo</var> examines the published property information of a class and
returns a pointer to the property information for property <var>PropName</var>.
The class to be examined can be specified in one of two ways:
</p>
<dl>
<dt>AClass</dt><dd>a class pointer.</dd>
<dt>Instance</dt><dd>an instance of the class to be investigated.</dd>
</dl>
<p>
If the property does not exist, a <var>EPropertyError</var> exception will be
raised. The <link id="GetPropInfo"/> function has the same function as the
<var>FindPropInfo</var> function, but returns <var>Nil</var> if the property does not
exist.
</p>
</descr>
<errors>
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="GetPropInfo"/>
<link id="GetPropList"/>
<link id="GetPropInfos"/>
</seealso>
<example file="typinfex/ex14"/>
</element>


<element name="GetEnumName">
<short>Return name of enumeration constant.</short>
<descr>
<p>
<var>GetEnumName</var> scans the type information for the enumeration type
described by <var>TypeInfo</var> and returns the name of the enumeration 
constant for the element with ordinal value equal to <var>Value</var>.
</p>
<p>
If <var>Value</var> is out of range, the first element of the enumeration type
is returned. The result is returned in the case that was used in the
declaration. (In earlier versions of FPC, the name was lowercased).
</p>
<p>
This can be used in combination with <var>GetOrdProp</var> to stream a property
of an enumerated type.
</p>
</descr>
<errors>
No check is done to determine whether <var>TypeInfo</var> really points to the 
type information for an enumerated type. 
</errors>
<seealso>
<link id="GetOrdProp"/>
<link id="GetEnumValue"/>
</seealso>
<example file="typinfex/ex9"/>
</element>


<element name="GetEnumProp">
<short>Return the value of an enumeration type property.</short>
<descr>
<var>GetEnumProp</var> returns the value of an property of an enumerated type
and returns the name of the enumerated value for the object <var>Instance</var>. 
The property whose value must be returned can be specified by its property 
info in <var>PropInfo</var> or by its name in <var>PropName</var>
</descr>
<errors>
No check is done to determine whether <var>PropInfo</var> really points to the 
property information for an enumerated type. 
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="SetEnumProp"/>
<link id="GetOrdProp"/>
<link id="GetStrProp"/>
<link id="GetInt64Prop"/>
<link id="GetMethodProp"/>
<link id="GetSetProp"/>
<link id="GetObjectProp"/>
<link id="GetEnumProp"/>
</seealso>
<example file="typinfex/ex2"/>
</element>


<element name="GetEnumValue">
<short>Get ordinal value for enumerated type by name</short>
<descr>
<p>
<var>GetEnumValue</var> scans the type information for the enumeration type
described by <var>TypeInfo</var> and returns the ordinal value for the element
in the enumerated type that has identifier <var>Name</var>. The identifier is
searched in a case-insensitive manner.
</p>
<p>
This can be used to set the value of enumerated properties from a stream. 
</p>
<p>
For an example, see <link id="GetEnumName"/>.
</p>
</descr>
<errors>
If <var>Name</var> is not found in the list of enumerated values, then -1 is
returned. No check is done whether <var>TypeInfo</var> points to the type information
for an enumerated type. 
</errors>
<seealso>
<link id="GetEnumName"/>
<link id="SetOrdProp"/>
</seealso>
</element>


<element name="GetFloatProp">
<short>Return value of floating point property</short>
<descr>
<var>GetFloatProp</var> returns the value of the float property described by 
<var>PropInfo</var> or with name <var>Propname</var> for the object <var>Instance</var>. 
All float types are converted
to extended.
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether
<var>PropInfo</var> describes a valid float property of <var>Instance</var>.
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="SetFloatProp"/>
<link id="GetOrdProp"/>
<link id="GetStrProp"/>
<link id="GetInt64Prop"/>
<link id="GetMethodProp"/>
<link id="GetSetProp"/>
<link id="GetObjectProp"/>
<link id="GetEnumProp"/>
</seealso>
<example file="typinfex/ex4"/>
</element>


<element name="GetInt64Prop">
<short>return value of an Int64 property</short>
<descr>
<remark>
Publishing of Int64 properties is not yet supported by Free Pascal. This
function is provided for Delphi compatibility only at the moment.
</remark>
<p>
<var>GetInt64Prop</var> returns the value of the property of type
<var>Int64</var> that is described by <var>PropInfo</var> or with name <var>Propname</var> 
for the object <var>Instance</var>.
</p>
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether
<var>PropInfo</var> describes a valid <var>Int64</var> property of <var>Instance</var>.
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception
</errors>
<seealso>
<link id="SetInt64Prop"/>
<link id="GetOrdProp"/>
<link id="GetStrProp"/>
<link id="GetFloatProp"/>
<link id="GetMethodProp"/>
<link id="GetSetProp"/>
<link id="GetObjectProp"/>
<link id="GetEnumProp"/>
</seealso>
<example file="typinfex/ex15"/>
</element>


<element name="GetMethodProp">
<short>Return value of a method property</short>
<descr>
<p>
<var>GetMethodProp</var> returns the method the property described by
<var>PropInfo</var> or with name <var>Propname</var> for object <var>Instance</var>.
The return type <var>TMethod</var> is defined in the <file>SysUtils</file> unit as:
</p>
<code>
TMethod = packed record
  Code, Data: Pointer;
end;                                                                         
</code>
<p>
<var>Data</var> points to the instance of the class with the method <var>Code</var>.
</p>
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether
<var>PropInfo</var> describes a valid method property of <var>Instance</var>.
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="SetMethodProp"/>
<link id="GetOrdProp"/>
<link id="GetStrProp"/>
<link id="GetFloatProp"/>
<link id="GetInt64Prop"/>
<link id="GetSetProp"/>
<link id="GetObjectProp"/>
<link id="GetEnumProp"/>
</seealso>
<example file="typinfex/ex6"/>
</element>


<element name="GetObjectProp">
<short>Return value of an object-type property.</short>
<descr>
<p>
<var>GetObjectProp</var> returns the object which the property described by
<var>PropInfo</var> with name <var>Propname</var> points to for object <var>Instance</var>.
</p>
<p>
If <var>MinClass</var> is specified, then if the object is not descendent of
class <var>MinClass</var>, then <var>Nil</var> is returned.
</p>
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether
<var>PropInfo</var> describes a valid method property of <var>Instance</var>. 
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="SetMethodProp"/>
<link id="GetOrdProp"/>
<link id="GetStrProp"/>
<link id="GetFloatProp"/>
<link id="GetInt64Prop"/>
<link id="GetSetProp"/>
<link id="GetObjectProp"/>
<link id="GetEnumProp"/>
</seealso>
<example file="typinfex/ex5"/>
</element>


<element name="GetObjectPropClass">
<short>Return class of property.</short>
<descr>
<p>
<var>GetObjectPropClass</var> returns the declared class of the property with name 
<var>PropName</var>. This may not be the actual class of the property value.
</p>
<p>
For an example, see <link id="GetObjectProp"/>.
</p>
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil.
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="SetMethodProp"/>
<link id="GetOrdProp"/>
<link id="GetStrProp"/>
<link id="GetFloatProp"/>
<link id="GetInt64Prop"/>
</seealso>
</element>


<element name="GetOrdProp">
<short>Get the value of an ordinal property</short>
<descr>
<p>
<var>GetOrdProp</var> returns the value of the ordinal property described by
<var>PropInfo</var> or with name <var>PropName</var> for the object <var>Instance</var>. 
The value is returned as a longint, which should be typecast to the 
needed type.
</p>
<p>
Ordinal properties that can be retrieved include:
</p>
<dl>
<dt>Integers and subranges of integers</dt>
<dd>The value of the integer will be returned.</dd>
<dt>Enumerated types and subranges of enumerated types</dt>
<dd>The ordinal value of the enumerated type will be returned.</dd>
<dt>Sets</dt>
<dd>If the base type of the set has less than 31 possible values.
If a bit is set in the return value, then the corresponding element of the
base ordinal class of the set type must be included in the set.
</dd>
</dl>
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether
<var>PropInfo</var> describes a valid ordinal property of <var>Instance</var>
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="SetOrdProp"/>
<link id="GetStrProp"/>
<link id="GetFloatProp"/>
<link id="GetInt64Prop"/>
<link id="GetMethodProp"/>
<link id="GetSetProp"/>
<link id="GetObjectProp"/>
<link id="GetEnumProp"/>
</seealso>
<example file="typinfex/ex1"/>
</element>


<element name="GetPropInfo">
<short>Return property type information, by property name.</short>
<descr>
<p>
<var>GetPropInfo</var> returns a pointer to the <var>TPropInfo</var> record for the 
<var>PropName</var> property of a class. The class to examine can be specified 
in one of three ways:
</p>
<dl>
<dt>Instance</dt><dd>An instance of the class.</dd>
<dt>AClass</dt><dd>A class pointer to the class.</dd>
<dt>TypeInfo</dt><dd>A pointer to the type information of the class.</dd>
</dl>
<p>
In each of these three ways, if <var>AKinds</var> is specified, if the property 
has <var>TypeKind</var> which is not included in <var>Akinds</var>, <var>Nil</var> will be
returned.
</p>
<p>
For an example, see most of the other functions.
</p>
</descr>
<errors>
If the property <var>PropName</var> does not exist, <var>Nil</var> is returned.
</errors>
<seealso>
<link id="GetPropInfos"/>
<link id="GetPropList"/>
</seealso>
</element>


<element name="GetPropInfos">
<short>Return a list of published properties.</short>
<descr>
<var>GetPropInfos</var> stores pointers to the property information of all published
properties of a class with class info <var>TypeInfo</var> in the list pointed to by
<var>Proplist</var>. The <var>PropList</var> pointer must point to a memory location that
contains enough space to hold all properties of the class and its parent classes.
</descr>
<errors>
No checks are done to see whether <var>PropList</var> points to a memory area that 
is big enough to hold all pointers.
</errors>
<seealso>
<link id="GetPropInfo"/>
<link id="GetPropList"/>
</seealso>
<example file="typinfex/ex12"/>
</element>


<element name="GetPropList">
<short>Return a list of a certain type of published properties.</short>
<descr>
<p>
<var>GetPropList</var> stores pointers to property information of the class with class
info <var>TypeInfo</var> for properties of kind <var>TypeKinds</var> in the list pointed to
by <var>Proplist</var>. <var>PropList</var> must contain enough space to hold all properties.
</p>
<p>
The function returns the number of pointers that matched the criteria and were stored
in <var>PropList</var>.
</p>
</descr>
<errors>
No checks are done to see whether <var>PropList</var> points to a memory area that is big enough
to hold all pointers.
</errors>
<seealso>
<link id="GetPropInfos"/>
<link id="GetPropInfo"/>
</seealso>
<example file="typinfex/ex13"/>
</element>


<element name="GetPropValue">
<short>Get property value as a string.</short>
<descr>
Due to missing <var>Variant</var> support, <var>GetPropValue</var> is not yet implemented. 
The declaration is provided for compatibility with Delphi.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="GetSetProp">
<short>Return the value of a set property.</short>
<descr>
<p>
<var>GetSetProp</var> returns the contents of a set property as a string.
The property to be returned can be specified by it's name in <var>PropName</var>
or by its property information in <var>PropInfo</var>.
</p>
<p>
The returned set is a string representation of the elements in the set as
returned by <link id="SetToString"/>. The <var>Brackets</var> option can be used to 
enclose the string representation in square brackets.
</p>
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether
<var>PropInfo</var> describes a valid ordinal property of <var>Instance</var>
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.                                                 
</errors>
<seealso>
<link id="SetSetProp"/>
<link id="GetStrProp"/>
<link id="GetFloatProp"/>
<link id="GetInt64Prop"/>
<link id="GetMethodProp"/>
</seealso>
<example file="typinfex/ex7"/>
</element>


<element name="GetStrProp">
<short>Return the value of a string property.</short>
<descr>
<var>GetStrProp</var> returns the value of the string property described by
<var>PropInfo</var> or with name <var>PropName</var> for object <var>Instance</var>. 
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether
<var>PropInfo</var> describes a valid string property of <var>Instance</var>.
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="SetStrProp"/>
<link id="SetWideStrProp"/>
<link id="GetOrdProp"/>
<link id="GetFloatProp"/>,
<link id="GetInt64Prop"/>
<link id="GetMethodProp"/>
</seealso>
<example file="typinfex/ex3"/>
</element>


<element name="GetTypeData">
<short>Return a pointer to type data, based on type information.</short>
<descr>
<var>GetTypeData</var> returns a pointer to the <var>TTypeData</var> record that
follows after the <var>TTypeInfo</var> record pointed to by <var>TypeInfo</var>.
It essentially skips the <var>Kind</var> and <var>Name</var> fields in the 
<var>TTypeInfo</var> record.
</descr>
<errors>
None.
</errors>
<seealso>
</seealso>
</element>

<element name="GetVariantProp">
<short>Return the value of a variant property.</short>
<descr>
Due to missing Variant support, the <var>GetVariantProp</var> function is not 
yet implemented. Provided for Delphi compatibility only.
</descr>
<errors>
</errors>
<seealso>
<link id="SetVariantProp"/>
</seealso>
</element>

<element name="IsPublishedProp">
<short>Check whether a published property exists.</short>
<descr>
<p>
<var>IsPublishedProp</var> returns true if a class has a published property with
name <var>PropName</var>. The class can be specified in one of two ways:
</p>
<dl>
<dt>AClass</dt><dd>A class pointer to the class.</dd>
<dt>Instance</dt><dd>An instance of the class.</dd>
</dl>
</descr>
<errors>
No checks are done to ensure <var>Instance</var> or <var>AClass</var> are valid
pointers. Specifying an invalid property name in <var>PropName</var> will result
in an <var>EPropertyError</var> exception.                                                 
</errors>
<seealso>
<link id="IsStoredProp"/>
<link id="PropIsType"/>
</seealso>
<example file="typinfex/ex10"/>
</element>


<element name="IsStoredProp">
<short>Check whether a property is stored.</short>
<descr>
<p>
<var>IsStoredProp</var> returns <var>True</var> if the <var>Stored</var> modifier evaluates
to <var>True</var> for the property described by <var>PropInfo</var> or with name
<var>PropName</var> for object <var>Instance</var>. 
It returns <var>False</var> otherwise. If the function returns
<var>True</var>, this indicates that the property should be written when
streaming the object <var>Instance</var>.
</p>
<p>
If there was no <var>stored</var> modifier in the declaration of the property, 
<var>True</var> will be returned. 
</p>
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether
<var>PropInfo</var> describes a valid property of <var>Instance</var>.
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.                                                 
</errors>
<seealso>
<link id="IsPublishedProp"/>
<link id="PropIsType"/>
</seealso>
<example file="typinfex/ex11"/>
</element>


<element name="PropIsType">
<short>Check the type of a published property.</short>
<descr>
<p>
<var>PropIsType</var> returns <var>True</var> if the property with name <var>PropName</var>
has type <var>TypeKind</var>. It returns <var>False</var> otherwise. The class to be
examined can be specified in one of two ways:
</p>
<dl>
<dt>AClass</dt><dd>A class pointer.</dd>
<dt>Instance</dt><dd>An instance of the class.</dd>
</dl>
</descr>
<errors>
No checks are done to ensure <var>Instance</var> or <var>AClass</var> are valid
pointers.Specifying an invalid property name in <var>PropName</var> will result
in an <var>EPropertyError</var> exception.                                                 
</errors>
<seealso>
<link id="IsPublishedProp"/>
<link id="IsStoredProp"/>
<link id="PropType"/>
</seealso>
<example file="typinfex/ex16"/>
</element>


<element name="PropType">
<short>Return the type of a property</short>
<descr>
<p>
<var>Proptype</var> returns the type of the property <var>PropName</var> for a class.
The class to be examined can be specified in one of 2 ways:
</p>
<dl>
<dt>AClass</dt><dd>A class pointer.</dd>
<dt>Instance</dt><dd>An instance of the class.</dd>
</dl>
</descr>
<errors>
No checks are done to ensure <var>Instance</var> or <var>AClass</var> are valid
pointers. Specifying an invalid property name in <var>PropName</var> will result
in an <var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="IsPublishedProp"/>
<link id="IsStoredProp"/>
<link id="PropIsType"/>
</seealso>
<example file="typinfex/ex17"/>
</element>


<element name="SetEnumProp">
<short>Set value of an enumerated-type property</short>
<descr>
<p>
<var>SetEnumProp</var> sets the property described by <var>PropInfo</var> or with name
<var>PropName</var> to <var>Value</var>. <var>Value</var> must be a string with the name
of the enumerate value, i.e. it can be used as an argument to 
<link id="GetEnumValue"/>.
</p>
<p>
For an example, see <link id="GetEnumProp"/>.
</p>
</descr>
<errors>
No checks are done to ensure <var>Instance</var> or <var>PropInfo</var> are valid
pointers. Specifying an invalid property name in <var>PropName</var> will result
in an <var>EPropertyError</var> exception.                                           
</errors>
<seealso>
<link id="GetEnumProp"/>
<link id="SetStrProp"/>
<link id="SetFloatProp"/>
<link id="SetInt64Prop"/>
<link id="SetMethodProp"/>
</seealso>
</element>


<element name="SetFloatProp">
<short>Set value of a float property.</short>
<descr>
<p>
<var>SetFloatProp</var> assigns <var>Value</var> to the property described by
<var>PropInfo</var> or with name <var>Propname</var> for the object <var>Instance</var>.
</p>
<p>
For an example, see <link id="GetFloatProp"/>.
</p>
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether
<var>PropInfo</var> describes a valid float property of <var>Instance</var>.
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="GetFloatProp"/>
<link id="SetOrdProp"/>
<link id="SetStrProp"/>,
<link id="SetInt64Prop"/>
<link id="SetMethodProp"/>
</seealso>
</element>



<element name="SetInt64Prop">
<short>Set value of a Int64 property</short>
<descr>
<p>
<var>SetInt64Prop</var> assigns <var>Value</var> to the property of type
<var>Int64</var> that is described by <var>PropInfo</var> or with name <var>Propname</var> 
for the object <var>Instance</var>.
</p>
<p>
For an example, see <link id="GetInt64Prop"/>.
</p>
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether
<var>PropInfo</var> describes a valid <var>Int64</var> property of <var>Instance</var>.
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="GetInt64Prop"/>
<link id="GetMethodProp"/>
<link id="SetOrdProp"/>
<link id="SetStrProp"/>
<link id="SetFloatProp"/>
</seealso>
</element>

<element name="SetMethodProp">
<short>Set the value of a method property</short>
<descr>
<p>
<var>SetMethodProp</var> assigns <var>Value</var> to the method the property described 
by <var>PropInfo</var> or with name <var>Propname</var> for object <var>Instance</var>.
</p>
<p>
The type <var>TMethod</var> of the <var>Value</var> parameter is defined in the
<file>SysUtils</file> unit as:
</p>
<code>
TMethod = packed record
  Code, Data: Pointer;
end;                                                                         
</code>
<p>
<var>Data</var> should point to the instance of the class with the method <var>Code</var>.
</p>
<p>
For an example, see <link id="GetMethodProp"/>.
</p>
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether
<var>PropInfo</var> describes a valid method property of <var>Instance</var>.
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="GetMethodProp"/>
<link id="SetOrdProp"/>
<link id="SetStrProp"/>
<link id="SetFloatProp"/>
<link id="SetInt64Prop"/>
</seealso>
</element>

<element name="SetObjectProp">
<short>Set the value of an object-type property.</short>
<descr>
<p>
<var>SetObjectProp</var> assigns <var>Value</var> to the object property described by
<var>PropInfo</var> or with name <var>Propname</var> for the object <var>Instance</var>. 
</p>
<p>
For an example, see <link id="GetObjectProp"/>.
</p>
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether
<var>PropInfo</var> describes a valid object property of <var>Instance</var>.
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="GetObjectProp"/>
<link id="SetOrdProp"/>
<link id="SetStrProp"/>
<link id="SetFloatProp"/>
<link id="SetInt64Prop"/>
<link id="SetMethodProp"/>
</seealso>
</element>


<element name="SetOrdProp">
<short>Set value of an ordinal property</short>
<descr>
<p>
<var>SetOrdProp</var> assigns <var>Value</var> to the ordinal property described by 
<var>PropInfo</var> or with name <var>Propname</var> for the object <var>Instance</var>. 
</p>
<p>
Ordinal properties that can be set include:
</p>
<dl>
<dt>Integers and subranges of integers</dt>
<dd>The actual value of the integer must be passed.</dd>
<dt>Enumerated types and subranges of enumerated types</dt>
<dd>The ordinal value of the enumerated type must be passed.</dd>
<dt>Subrange types</dt>
<dd>of integers or enumerated types. Here the ordinal value must be passed.</dd>
<dt>Sets</dt>
<dd>If the base type of the set has less than 31 possible values. 
For each possible value; the corresponding bit of <var>Value</var> must be set.</dd>
</dl>
<p>
For an example, see <link id="GetOrdProp"/>.
</p>
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether
<var>PropInfo</var> describes a valid ordinal property of <var>Instance</var>. 
No range checking is performed.
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="GetOrdProp"/>
<link id="SetStrProp"/>
<link id="SetFloatProp"/>
<link id="SetInt64Prop"/>
<link id="SetMethodProp"/>
</seealso>
</element>


<element name="SetPropValue">
<short>Set property value as variant</short>
<descr>
Due to missing Variant support, this function is not yet implemented;
it is provided for Delphi compatibility only.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<element name="SetSetProp">
<short>Set value of set-typed property.</short>
<descr>
<p>
<var>SetSetProp</var> sets the property specified by <var>PropInfo</var> or
<var>PropName</var> for object <var>Instance</var> to <var>Value</var>. <var>Value</var> is a
string which contains a comma-separated list of values, each value being a
string-representation of the enumerated value that should be included in
the set. The value should be accepted by the <link id="StringToSet"/> function.
</p>
<p>
The value can be formed using the <link id="SetToString"/> function.
</p>
<p>
For an example, see <link id="GetSetProp"/>.
</p>
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether
<var>PropInfo</var> describes a valid ordinal property of <var>Instance</var>.
No range checking is performed.
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.                                                 
</errors>
<seealso>
<link id="GetSetProp"/>
<link id="SetOrdProp"/>
<link id="SetStrProp"/>
<link id="SetFloatProp"/>
<link id="SetInt64Prop"/>
<link id="SetMethodProp"/>
<link id="SetToString"/>
<link id="StringToSet"/>
</seealso>
</element>


<element name="SetStrProp">
<short>Set value of a string property</short>
<descr>
<p>
<var>SetStrProp</var> assigns <var>Value</var> to the string property described by
<var>PropInfo</var> or with name <var>Propname</var> for object <var>Instance</var>. 
</p>
<p>
For an example, see <link id="GetStrProp"/>
</p>
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether
<var>PropInfo</var> describes a valid string property of <var>Instance</var>.
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="GetStrProp"/>
<link id="SetWideStrProp"/>
<link id="SetOrdProp"/>
<link id="SetFloatProp"/>,
<link id="SetInt64Prop"/>
<link id="SetMethodProp"/>
</seealso>
</element>


<element name="SetToString">
<short>Convert set to a string description</short>
<descr>
<p>
<var>SetToString</var> takes an integer representation of a set (as received e.g.
by <var>GetOrdProp</var>) and turns it into a string representing the elements in
the set, based on the type information found in the <var>PropInfo</var> property
information. By default, the string representation is not surrounded by
square brackets. Setting the <var>Brackets</var> parameter to <var>True</var> will 
surround the string representation with brackets.
</p>
<p>
The function returns the string representation of the set.
</p>
</descr>
<errors>
No checking is done to see whether <var>PropInfo</var> points to valid property
information.
</errors>
<seealso>
<link id="GetEnumName"/>
<link id="GetEnumValue"/>
<link id="StringToSet"/>
</seealso>
<example file="typinfex/ex18"/>
</element>


<element name="SetVariantProp">
<short>Set value of a variant property</short>
<descr>
Due to missing Variant support, this function is not yet implemented. 
Provided for Delphi compatibility only.
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>


<element name="StringToSet">
<short>Convert string description to a set.</short>
<descr>
<p>
<var>StringToSet</var> converts the string representation of a set in <var>Value</var>
to a integer representation of the set, using the property information found
in <var>PropInfo</var>. This property information should point to the property
information of a set property. The function returns the integer
representation of the set. (i.e, the set value, typecast to an integer)
</p>
<p>
The string representation can be surrounded with square brackets, and must 
consist of the names of the elements of the base type of the set. The base
type of the set should be an enumerated type. The elements should be
separated by commas, and may be surrounded by spaces.
each of the names will be fed to the <link id="GetEnumValue"/> function.
</p>
<p>
For an example, see <link id="SetToString"/>.
</p>
</descr>
<errors>
No checking is done to see whether <var>PropInfo</var> points to valid property
information. If a wrong name is given for an enumerated value, then an
<var>EPropertyError</var> will be raised.
</errors>
<seealso>
<link id="GetEnumName"/>
<link id="GetEnumValue"/>
<link id="SetToString"/>
</seealso>
</element>

<element name="OnGetPropValue">
<short>Callback to get a property value as a variant.</short>
<descr>
This callback is set by the variants unit to enable reading of properties as
a variant. If set, it is called by the <link id="GetPropValue"/> function.
</descr>
</element>


<element name="OnGetVariantprop">
<short>Callback to get a variant property value.</short>
<descr>
This callback is set by the variants unit to enable reading of variant properties
If set, it is called by the <link id="GetVariantProp"/> function.
</descr>
</element>


<element name="OnSetPropValue">
<short>Callback to set a property value as a variant.</short>
<descr>
This callback is set by the variants unit to enable writing of properties as
a variant. If set, it is called by the <link id="SetPropValue"/> function.
</descr>
</element>


<element name="OnSetVariantprop">
<short>Callback to set a variant property value.</short>
<descr>
This callback is set by the variants unit to enable writing of variant
properties. If set, it is called by the <link id="GetVariantProp"/> function.
</descr>
</element>


<element name="TGetPropValue">
<short>Callback type for the <link id="#rtl.TypInfo.OnGetPropValue">OnGetPropValue</link> callback
event</short>.
<descr>
The callback function must return the property with name <var>PropName</var>
of instance <var>Instance</var>. If <var>PreferStrings</var> is true, it
should favour converting the property to a string value. The function needs
to return the variant with the property value.
</descr>
</element>



<element name="TGetVariantProp">
<short>Callback type for the <link id="#rtl.TypInfo.OnGetVariantProp">OnGetVariantProp</link> callback
event</short>.
<descr>
The callback function must return the variant property with name <var>PropName</var>
of instance <var>Instance</var>.
</descr>
</element>


<element name="TSetPropValue">
<short>Callback type for the <link id="#rtl.TypInfo.OnSetPropValue">OnSetPropValue</link> callback
event</short>.
<descr>
The callback function must set the property with name <var>PropName</var>
of instance <var>Instance</var> to <var>Value</var>.
</descr>
</element>


<element name="TSetVariantProp">
<short>Callback type for the <link id="#rtl.TypInfo.OnSetVariantProp">OnSetVariantProp</link> callback
event</short>.
<descr>
The callback function must set the variant property with name <var>PropName</var>
of instance to <var>Value</var>.
</descr>
</element>

<!-- enumeration type Visibility: default -->
<element name="TParamFlag">
<short>Function or procedure parameter flags.</short>
<descr>
<var>TParamFlag</var> describes a parameter.
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TParamFlag.pfVar">
<short>Parameter is a var parameter (passed by reference)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TParamFlag.pfConst">
<short>Parameter is a const parameter (i.e. cannot be modified)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TParamFlag.pfArray">
<short>Parameter is an array parameter</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TParamFlag.pfAddress">
<short>Parameter is passed by address</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TParamFlag.pfReference">
<short>Parameter is passed by reference</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TParamFlag.pfOut">
<short>Parameter is a string parameter</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TIntfFlag.ifHasStrGUID">
<short>Interface has a string GUID identifier</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.OrdType">
<short>Type is an ordinal type</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.MinValue">
<short>Minimum value for the (subrange) type.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.MaxValue">
<short>Maximum value for the (subrange) type.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.BaseType">
<short>Base type on which this type is based.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.NameList">
<short>List of names for an enumerated type</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.CompType">
<short>Comp type</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.FloatType">
<short>Float type</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.MaxLength">
<short>Maximum length (for a shortstring type)</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.ClassType">
<short>Class type</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.ParentInfo">
<short>Parent class type info</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.PropCount">
<short>Property count for class type</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.UnitName">
<short>Unit name in which type is defined.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.MethodKind">
<short>Kind of method</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.ParamCount">
<short>Method parameter count</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.ParamList">
<short>Type data for parameters</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.MinInt64Value">
<short>Minimum Int64 value for subrange type.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.MaxInt64Value">
<short>Maximum int64 value for subrange type.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.MinQWordValue">
<short>Minimum QWord value for a subrange type.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.MaxQWordValue">
<short>Maximum QWord value for a subrange type.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.IntfParent">
<short>Parent interface type data.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.IntfFlags">
<short>Interface flags</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.GUID">
<short>GUID identification for interface</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.IntfUnit">
<short>Interface unit.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.RawIntfParent">
<short>Raw interface parent.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.RawIntfFlags">
<short>Raw interface parent flags.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.IID">
<short>GUID identifying raw interface.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.RawIntfUnit">
<short>Raw interface unit.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.IIDStr">
<short>IID string representation of interface</short>
</element>

<!-- variable Visibility: default -->
<element name="TPropData.PropCount">
<short>Property count.</short>
</element>

<!-- variable Visibility: default -->
<element name="_alignmentdummy">
<short>Pad data</short>
</element>

<!-- variable Visibility: default -->
<element name="TPropData.PropList">
<short>Property list</short>
</element>

<!-- function Visibility: default -->
<element name="GetWideStrProp">
<short>Read a widestring property</short>
<descr>
<var>GetWideStrProp</var> returns the value of the widestring property described by
<var>PropInfo</var> or with name <var>PropName</var> for object <var>Instance</var>.
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether
<var>PropInfo</var> describes a valid widestring property of <var>Instance</var>.
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="GetStrProp"/>
<link id="SetWideStrProp"/>
<link id="GetOrdProp"/>
<link id="GetFloatProp"/>,
<link id="GetInt64Prop"/>
<link id="GetMethodProp"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetWideStrProp">
<short>Set a widestring property</short>
<descr>
<p>
<var>SetWideStrProp</var> assigns <var>Value</var> to the widestring property described by
<var>PropInfo</var> or with name <var>Propname</var> for object <var>Instance</var>.
</p>
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether
<var>PropInfo</var> describes a valid widestring property of <var>Instance</var>.
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="GetWideStrProp"/>
<link id="SetStrProp"/>
<link id="SetOrdProp"/>
<link id="SetFloatProp"/>,
<link id="SetInt64Prop"/>
<link id="SetMethodProp"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="GetEnumNameCount">
<short>Return number of names in an enumerated type</short>
<descr>
<var>GetEnumNameCount</var> returns the number of values (names) in the enumerated type,
described by <var>enum1</var>
</descr>
<errors>
No checking is done to see whether <var>Enum1</var> is really type information of  an enumerated type.
</errors>
<seealso>
<link id="GetEnumValue"/>
<link id="GetEnumName"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="ShortStringBase">
<short>Short string type definition</short>
<descr>
<var>ShortStringBase</var> is the base definition of a short string.
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.elSize">
<short>Dynamical array element size</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.elType2">
<short>Dynamical array Element type</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.varType">
<short>Dynamical array element type</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.elType">
<short>Dynamical array Element type</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.DynUnitName">
<short>Unit name</short>
</element>

<!-- variable Visibility: default -->
<element name="_alignmentdummy">
<short>Dummy for alignment purposes</short>
</element>

<!--
  function GetInterfaceProp(Instance: TObject; const PropName: string): IInterface;
  function GetInterfaceProp(Instance: TObject; PropInfo: PPropInfo): IInterface;
  procedure SetInterfaceProp(Instance: TObject; const PropName: string; const Value: IInterface);
  procedure SetInterfaceProp(Instance: TObject; PropInfo: PPropInfo; const Value: IInterface);
-->

<!-- function Visibility: default -->
<element name="GetInterfaceProp">
<short>Return interface-typed property</short>
<descr>
<p>
<var>GetInterfaceProp</var> returns the interface which the property described by
<var>PropInfo</var> or with name <var>Propname</var> points to for object <var>Instance</var>.
</p>
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether <var>PropInfo</var> describes a valid method property of
<var>Instance</var>. Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="SetInterfaceProp"/>
<link id="GetOrdProp"/>
<link id="GetStrProp"/>
<link id="GetFloatProp"/>
<link id="GetInt64Prop"/>
<link id="GetSetProp"/>
<link id="GetObjectProp"/>
<link id="GetEnumProp"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetInterfaceProp">
<short>Set interface-valued property</short>
<descr>
<var>SetInterfaceProp</var> assigns <var>Value</var> to the object property described by
<var>PropInfo</var> or with name <var>Propname</var> for the object <var>Instance</var>.
</descr>
<errors>
No checking is done whether <var>Instance</var> is non-nil, or whether <var>PropInfo</var> 
describes a valid interface property of <var>Instance</var>.
Specifying an invalid property name in <var>PropName</var> will result in an
<var>EPropertyError</var> exception.
</errors>
<seealso>
<link id="GetInterfaceProp"/>
<link id="SetObjectProp"/>
<link id="SetOrdProp"/>
<link id="SetStrProp"/>
<link id="SetFloatProp"/>
<link id="SetInt64Prop"/>
<link id="SetMethodProp"/>
</seealso>
</element>

<!--
  ********************************************************************
    #rtl.typinfo.EPropertyConvertError
  ********************************************************************
-->

<!-- object Visibility: default -->
<element name="EPropertyConvertError">
<short>Exception raised when converting a property</short>
<descr>
<var>EPropertyConvertError</var> is not used in the Free Pascal
implementation of the typinfo unit, but is declared for Delphi
compatibility.
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTypeKind.tkProcVar">
<short>Procedural variable</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTypeKind.tkUString">
<short>Unicode string</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTypeKind.tkUChar">
<short>Unicode character</short>
</element>

<!-- variable Visibility: default -->
<element name="_alignmentdummy">
<short>Dummy used for alignment</short>
</element>

<!-- function Visibility: default -->
<element name="GetUnicodeStrProp">
<short>Get UnicodeString-valued property</short>
<descr>
<var>GetUnicodeStrProp</var> returns the UnicodeString property from
<var>Instance</var>, where the property is identified by the
<var>PropInfo</var> pointer or the <var>PropertyName</var>.
</descr>
<errors>
If no property of the indicated name exists, or the value is not a Unicode
string, an exception will occur.
</errors>
<seealso>
<link id="GetStrProp"/>
<link id="SetUnicodeStrProp"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetUnicodeStrProp">
<short>Set UnicodeString-valued property</short>
<descr>
<var>SetUnicodeStrProp</var> sets the UnicodeString property from
<var>Instance</var> to <var>Value</var>, where the property is 
identified by the <var>PropInfo</var> pointer or the <var>PropertyName</var>.
</descr>
<errors>
If no property of the indicated name exists, or it is not of type  unicodestring, 
an exception will occur.
</errors>
<seealso>
<link id="SetStrProp"/>
<link id="GetUnicodeStrProp"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PVmtFieldEntry">
<short>Pointer to <link id="#rtl.typinfo.TVmtFieldEntry"/> type.</short>
<descr>
</descr>
<seealso>
<link id="TVmtFieldEntry"/>
<link id="TVmtFieldTable"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TVmtFieldEntry">
<short>Describe a field of a record/class</short>
<descr>
<var>TVmtFieldEntry</var> records are generated by the compiler for all
fields of a record or class that have RTTI associated with them. They
describe the field as known to the compiler.
</descr>
<seealso>
<link id="PVmtFieldEntry"/>
<link id="TVmtFieldTable"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TVmtFieldEntry.FieldOffset">
<short>Offset of the field from the start of the class data</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmtFieldEntry.TypeIndex">
<short>Type of the field</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmtFieldEntry.Name">
<short>Name of the field</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PVmtFieldTable">
<short>Pointer to <link id="#rtl.typinfo.TVmtFieldTable"/> type.</short>
<seealso>
<link id="TVmtFieldTable"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TVmtFieldTable">
<short>Table of field descriptions for a class or record type.</short>
<descr>
<var>TVmtFieldTable</var> describes the fields for which RTTI was generated.
A <var>TVmtFieldTable</var> entry is generated by the compiler in the RTTI
information, it is not something one creates manually.
Basically it contains a list of <link id="TVmtFieldEntry"/> values. 
</descr>
<seealso>
<link id="TVmtFieldEntry"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TVmtFieldTable.Count">
<short>Number of fields in the table</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmtFieldTable.ClassTab">
<short>Class table</short>
</element>

<!-- variable Visibility: default -->
<element name="TVmtFieldTable.Fields">
<short>Array of fields. Note that the elements in the table have variable size</short>
</element>

<!-- variable Visibility: default -->
<element name="_alignmentdummy">
<short>Dummy for alignment purposes</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTypeKind.tkHelper">
<short>Helper class type.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TMethodKind.mkClassConstructor">
<short>Class constructor method.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TMethodKind.mkClassDestructor">
<short>Class destructor method.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TMethodKind.mkOperatorOverload">
<short>Operator overloader</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TCallConv">
<short>Calling convention enumerator</short>
<descr>
<var>TCallConv</var> is a type describing the calling convention used by a
method. It contains an element for all supported calling conventions.
</descr>
<seealso>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCallConv.ccReg">
<short>Register calling convention</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCallConv.ccCdecl">
<short>Cdecl calling convention.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCallConv.ccPascal">
<short>Pascal calling convention.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCallConv.ccStdCall">
<short>stdcall calling convention.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCallConv.ccSafeCall">
<short>SafeCall calling convention.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCallConv.ccCppdecl">
<short>Cppdecl calling convention</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCallConv.ccFar16">
<short>Far16 calling convention (Delphi compatibility)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCallConv.ccOldFPCCall">
<short>OldFPCCall calling convention (deprecated)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCallConv.ccInternProc">
<short>InternProc calling convention (compiler internal)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCallConv.ccSysCall">
<short>SysCall calling convention.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCallConv.ccSoftFloat">
<short>Softfloat calling convention.</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TCallConv.ccMWPascal">
<short>MWPascal (MetroWerks Pascal) calling convention.</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.HelperParent">
<short>Type information for parent helper class</short>
<descr>
<var>HelperParent</var> points to the type information of the parent helper
class. It is <var>Nil</var> if there is no parent class.
</descr>
<seealso>
<link id="TTypeData.ExtendedInfo"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.ExtendedInfo">
<short>Type information for the extended type (record or class).</short>
<descr>
<var>ExtendedInfo</var> points to the type information of the type that is
being extended.
</descr>
<seealso>
<link id="TTypeData.HelperParent"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.HelperProps">
<short>Number of properties provided by the helper.</short>
<descr>
<var>HelperProps</var> contains the count of the published properties
provided by the helper class.
</descr>
<seealso>
<link id="TTypeData.HelperUnit"/>
<link id="TTypeData.HelperParent"/>
<link id="TTypeData.ExtendedInfo"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.HelperUnit">
<short>Unit the helper class is defined in.</short>
<descr>
<var>HelperUnit</var> contains the name of the unit that defines the helper
class.
</descr>
<seealso>
<link id="TTypeData.HelperProps"/>
<link id="TTypeData.HelperParent"/>
<link id="TTypeData.ExtendedInfo"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TPropData._alignmentdummy">
<short>Padding alignment</short>
</element>

<!-- function Visibility: default -->
<element name="GetRawInterfaceProp">
<short>Get a raw (CORBA) interface property.</short>
<descr>
<var>GetRawInterfaceProp</var> can be used to retrieve the value of a published CORBA interface
property with name <var>PropName</var> from object <var>Instance</var>.
Alternatively, the required property information can be specified by
<var>PropInfo</var> instead of the property name.
In difference with the <link id="GetInterfaceProp"/> function, no reference
counting is done.
</descr>
<errors>
If the property <var>PropName</var> does not exist, an <var>EPropertyError</var> exception is
raised.
</errors>
<seealso>
<link id="GetInterfaceProp"/>
<link id="SetRawInterfaceProp"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetRawInterfaceProp">
<short>Set a raw (CORBA) interface property.</short>
<descr>
<var>SetRawInterfaceProp</var> can be used to set the value of a published CORBA
interface with name <var>PropName</var> from object <var>Instance</var> to
<var>Value</var>. Alternatively, the required property information can be 
specified by <var>PropInfo</var> instead of the property name.
In difference with the <link id="SetInterfaceProp"/> procedure, no reference
counting is done.
</descr>
<errors>
If the property <var>PropName</var> does not exist, an <var>EPropertyError</var> exception is
raised.
</errors>
<seealso>
<link id="SetInterfaceProp"/>
<link id="GetRawInterfaceProp"/>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTypeKind.tkFile">
<short>File type (both text and binary)</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTypeKind.tkClassRef">
<short>Class of type</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TTypeKind.tkPointer">
<short>Pointer type</short>
</element>

<!-- record type Visibility: default -->
<element name="TArrayTypeData">
<short>Array type data</short>
<descr>
<var>TArrayTypeData</var> is used to describe arrays in RTTI. It can be
encountered when the type kind is <var>tkArray</var>, and is used for both
static and dynamic arrays and single or multi-dimensional arrays. 
The type of the array elements is described in <var>elType</var>, and the ranges
for each of the dimensions (specified in <var>DimCount</var> in <var>Dims</var>.
</descr>
<seealso>
<link id="TTypeInfo"/>
<link id="TTypeKind"/>
<link id="TTypeData"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TArrayTypeData.Size">
<short>Declared size of the array</short>
</element>

<!-- variable Visibility: default -->
<element name="TArrayTypeData.ElCount">
<short>Total number of elements in the array</short>
</element>

<!-- variable Visibility: default -->
<element name="TArrayTypeData.ElType">
<short>Type information for an element in the array</short>
</element>

<!-- variable Visibility: default -->
<element name="TArrayTypeData.DimCount">
<short>Number of dimensions in the array</short>
</element>

<!-- variable Visibility: default -->
<element name="TArrayTypeData.Dims">
<short>Range information for each dimension in the array</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PManagedField">
<short>Pointer to <var>TManagedField</var></short>
<descr>
<var>PManagedField</var> is a pointer to <link id="TManagedField"/>. It is
used to describe automatically managed fields in records when the type kind
is <var>tkRecord</var>.
</descr>
<seealso>
<link id="TManagedField"/>
<link id="TTypeKind"/>
<link id="TTypeData"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TManagedField">
<short>Managed field description</short>
<descr>
<var>TManagedField</var> describes 1 managed field in a record. It consists
of type information (<var>TypeRef</var>) and an offset in the record's
memory layout (<var>FldOffset</var>). Size can be determined from the type
information.
</descr>
<seealso>
<link id="TManagedField"/>
<link id="TTypeKind"/>
<link id="TTypeData"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TManagedField.TypeRef">
<short>Type information for the field</short>
</element>

<!-- variable Visibility: default -->
<element name="TManagedField.FldOffset">
<short>Offset in the record memory layout</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PProcedureParam">
<short>Pointer to <var>TProcedureParam</var></short>
<descr>
<var>PProcedureParam</var> is a pointer to <var>TProcedureParam</var>. 
It is used in <link id="TProcedureSignature"/>.
</descr>
<seealso>
<link id="TProcedureParam"/>
<link id="TProcedureSignature"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TProcedureParam">
<short>Procedure parameter description</short>
<descr>
<var>TProcedureParam</var> describes a single parameter to a procedure (or function). 
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TProcedureParam.Flags">
<short>Flags for this parameter (see TParamFlags)</short>
</element>

<!-- variable Visibility: default -->
<element name="TProcedureParam.ParamType">
<short>Type information for this parameter</short>
</element>

<!-- variable Visibility: default -->
<element name="TProcedureParam.Name">
<short>Parameter name as in declaration.</short>
</element>

<!-- record type Visibility: default -->
<element name="TProcedureSignature">
<short>Procedure signature description record</short>
<descr>
<var>TProcedureSignature</var> describes a procedure/method call signature.
It consists of some flags (<var>Flags</var>), a calling convention
(<var>CC</var>), the result type (<var>ResultType</var>) if any, and a list
of <var>ParamCount</var> parameters (of type <link id="TProcedureParam"/>).
</descr>
<seealso>
<link id="TProcedureParam"/>
<link id="TCallConv"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TProcedureSignature.Flags">
<short>Flags for this procedure</short>
</element>

<!-- variable Visibility: default -->
<element name="TProcedureSignature.CC">
<short>Calling convention for this procedure</short>
</element>

<!-- variable Visibility: default -->
<element name="TProcedureSignature.ResultType">
<short>Result type info (Nil if no result)</short>
</element>

<!-- variable Visibility: default -->
<element name="TProcedureSignature.ParamCount">
<short>Number of parameter descriptions following the signature.</short>
</element>

<!-- function Visibility: default -->
<element name="TProcedureSignature.GetParam">
<short>Get parameter signature</short>
<descr>
<var>GetParam</var> can be used to retrieve a pointer to the description of a
parameter. The index <var>ParamIndex</var> is zero-based. 
</descr>
<errors>
In case of an invalid parameter index, <var>Nil</var> is returned.
</errors>
<seealso>
<link id="TProcedureParam"/>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.CodePage">
<short>Codepage for a single-byte string type</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.RecSize">
<short>Record size for records</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.ManagedFldCount">
<short>Number of managed fields (followed by managed field info)</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.ProcSig">
<short>Procedure signature for procedure type</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.ArrayData">
<short>Array element data</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.InstanceType">
<short>Pointer to instance type data</short>
</element>

<!-- variable Visibility: default -->
<element name="TTypeData.RefType">
<short>Type info for referred type (Nil for untyped pointer)</short>
</element>

<!-- constant Visibility: default -->
<element name="tkProcedure">
<short>Procedure kind</short>
</element>

<!-- uses unit Visibility: default -->
<element name="SysUtils">
<short>Exceptions</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOrdType.otSQWord">
<short>Signed QWord</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TOrdType.otUQWord">
<short>Unsigned QWord</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TParamFlag.pfConstRef">
<short>Constref parameter type</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TParamFlag.pfHidden">
<short>hidden parameter type</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TParamFlag.pfHigh">
<short>High bound parameter type</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TParamFlag.pfSelf">
<short>Self parameter type</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TParamFlag.pfVmt">
<short>VMT parameter type</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TParamFlag.pfResult">
<short>Result location parameter</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TSubRegister">
<short>CPU Sub register size/location</short>
<descr>
<var>TSubRegister</var> describes CPU sub-register sizes or locations.
</descr>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSubRegister.None">
<short>None</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSubRegister.Lo">
<short>Low</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSubRegister.Hi">
<short>High</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSubRegister.Word">
<short>Word size</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSubRegister.DWord">
<short>DWord size</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSubRegister.QWord">
<short>QWord size</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSubRegister.FloatSingle">
<short>Single-sized float value</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSubRegister.FloatDouble">
<short>Double-sized float value</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSubRegister.FloatQuad">
<short>Quadruple-sized float value</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSubRegister.MultiMediaSingle">
<short>Multimedia register single-sized float</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSubRegister.MultiMediaDouble">
<short>Multimedia register double-sized float</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSubRegister.MultiMediaWhole">
<short>Multimedia register whole-sized</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSubRegister.MultiMediaX">
<short>Multimedia register X position</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TSubRegister.MultiMediaY">
<short>Multimedia register Y position</short>
</element>

<!-- enumeration type Visibility: default -->
<element name="TRegisterType">
<short>Register type</short>
<descr>
<var>TRegisterType</var>  describes the type of the CPU register.
</descr>
<seealso>
</seealso>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRegisterType.Invalid">
<short>Invalid register</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRegisterType.Int">
<short>Integer register</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRegisterType.FP">
<short>Floating-point register</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRegisterType.MMX">
<short>MMX register</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRegisterType.MultiMedia">
<short>Multimedia register</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRegisterType.Special">
<short>Special register</short>
</element>

<!-- enumeration value Visibility: default -->
<element name="TRegisterType.Address">
<short>Address register</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PParameterLocation">
<short>Pointer to <var>TParameterLocation</var></short>
<descr>
<var>PParameterLocation</var> defines a pointer to a <link id="TParameterLocation"/> record.
</descr>
<seealso>
<link id="TParameterLocation"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TParameterLocation">
<short>Describe a method argument (parameter) location</short>
<descr>
<p>
<var>TParameterLocation</var> is used by RTTI to describe the location of a parameter (argument) when arguments are passed to a method call.
It has the same memory layout as the actual RTTI data. It offers the following fields and properties:
</p>
<dl>
<dt>RegSub</dt><dd><printshort id="TParameterLocation.RegSub"/></dd>
<dt>RegNumber</dt><dd><printshort id="TParameterLocation.RegNumber"/></dd>
<dt>Offset</dt><dd><printshort id="TParameterLocation.Offset"/></dd>
<dt>Property Reference</dt><dd><printshort id="TParameterLocation.Reference"/></dd>
<dt>Property RegType</dt><dd><printshort id="TParameterLocation.RegType"/></dd>
<dt>Property ShiftVal</dt><dd><printshort id="TParameterLocation.ShiftVal"/></dd>
</dl>
</descr>
<seealso>
<link id="TParameterLocation"/>
<link id="TRegisterType"/>
<link id="TSubRegister"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TParameterLocation.RegSub">
<short>Sub register indicator</short>
</element>

<!-- variable Visibility: public -->
<element name="TParameterLocation.RegNumber">
<short>Register number</short>
</element>

<!-- variable Visibility: public -->
<element name="TParameterLocation.Offset">
<short>Stack offset or index of register</short>
</element>

<!-- property Visibility: public -->
<element name="TParameterLocation.Reference">
<short>Is the offset a stack offset or register index</short>
<descr>
<var>Reference</var> indicates whether the register is the index register (<var>True</var>), otherwise the
register in wihch (part of) the parameter resides.
</descr>
<seealso>
<link id="TParameterLocation.ShiftVal"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TParameterLocation.RegType">
<short>Register type</short>
<descr>
<var>RegType</var> returns the type of the register location. It is calculated from a private field.
</descr>
<seealso>
<link id="TRegisterType"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TParameterLocation.ShiftVal">
<short>Register shift</short>
<descr>
<var>ShiftVal</var> is zero if <link id="TParameterLocation.Reference">Reference</link> is false, or <var>Offset</var> otherwise.
</descr>
<seealso>
<link id="TParameterLocation.Reference">Reference</link>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PParameterLocations">
<short>Pointer to <var>TParameterLocations</var> record</short>
<descr>
<var>PParameterLocations</var> points to a <link id="TParameterLocations"/> record.
</descr>
<seealso>
<link id="TParameterLocations"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TParameterLocations">
<short>Array of method parameter location descriptions</short>
<descr>
<var>TParameterLocations</var> is used by RTTI to describe the array of locations of method parameters (arguments) when arguments are passed to a method call.
It describes the memory layout of the actual RTTI data. It offers the following fields and properties:
</descr>
<seealso>
<link id="PParameterLocations"/>
<link id="TParameterLocation"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TParameterLocations.Count">
<short>Parameter count</short>
</element>

<!-- property Visibility: public -->
<element name="TParameterLocations.Location">
<short>Indexed access to the various parameter location descriptors</short>
<descr>
<var>Location</var> offers indexed access to the various <link id="TParameterLocation"/> records that make up a method's parameters description.
Note that it returns a pointer to the actual record, not a copy of the record.
</descr>
<seealso>
<link id="PParameterLocations"/>
<link id="TParameterLocation"/>
<link id="PParameterLocation"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TParameterLocations.Tail">
<short>Memory location after parameter data.</short>
<descr>
<var>Tail</var> points to the memory location after the <var>TParameterLocations</var> data (the last <link id="TParameterLocation"/> record).
It can be used to get the location of the next structure in the RTTI.
</descr>
<seealso>
<link id="TParameterLocation"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PVmtFieldClassTab">
<short>Pointer to <var>TVmtFieldClassTab</var>.</short>
<descr>
  <var>PVmtFieldClassTab</var> points to a <link id="TVmtFieldClassTab"/> record.
</descr>
<seealso>
<link id="TVmtFieldClassTab"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TVmtFieldClassTab">
<short>Table with Class-typed Fields.</short>
<descr>
<var>TVmtFieldClassTab</var> describes the fields of class type.
A pointer to this table is present in <link id="TVmtFieldTable"/>
</descr>
<seealso>
  <link id="TVmtFieldTable"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TVmtFieldClassTab.Count">
<short>Number of entries.</short>
</element>

<!-- variable Visibility: public -->
<element name="TVmtFieldClassTab.ClassRef">
<short>Array of class references.</short>
</element>

<!-- property Visibility: public -->
<element name="TVmtFieldEntry.Tail">
<short>Pointer to the next RTTI structure.</short>
<descr>
<var>Tail</var> points to the memory location after the <var>TVmtFieldEntry</var> record.
This can be another <var>TVmtFieldEntry</var> record or an entirely different data structure.
</descr>
<seealso>
<link id="TVmtFieldEntry.Next"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TVmtFieldEntry.Next">
<short>Pointer to the next <var>TVmtFieldEntry</var>.</short>
<descr>
  <var>Next</var> is the same as <link id="TVmtFieldEntry.Tail"/>, but is typed.
Note that on the last <var>TVmtFieldEntry</var> in the array, the next element is not a <var>TVmtFieldEntry</var>.
</descr>
<seealso>
<link id="TVmtFieldEntry.Tail"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TVmtFieldTable.Field">
<short>Indexed access to the fields in the table.</short>
<descr>
<var>Field</var> returns the location of the <var>aIndex</var>the field in the table.
</descr>
<seealso>
<link id="TVmtFieldEntry"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PPropData">
<short>Pointer to <var>TPropData</var>.</short>
<descr>
  <var>PPropData</var> is a pointer to a <link id="TPropData"/> record.
</descr>
<seealso>
<link id="TPropData"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TArrayTypeData.ElTypeRef">
<short>Reference to element type info.</short>
</element>

<!-- variable Visibility: public -->
<element name="TArrayTypeData.DimsRef">
<short>Reference to dimension data.</short>
</element>

<!-- variable Visibility: public -->
<element name="TManagedField.TypeRefRef">
<short>Reference to type info of a managed field.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PInitManagedField">
<short>Pointer to <var>TInitManagedField</var> record.</short>
<descr>
  <var>PInitManagedField</var> is a pointer to a <link id="TInitManagedField"/> record.
</descr>
<seealso>
<link id="TInitManagedField"/>
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="TInitManagedField">
<short>Alias for <var>TManagedField</var>.</short>
<descr>
<var>TInitManagedField</var> is an alias for <link id="TManagedField"/>.
</descr>
<seealso>
<link id="TManagedField"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TProcedureParam.ParamFlags">
<short>Parameter flags.</short>
</element>

<!-- variable Visibility: public -->
<element name="TProcedureParam.ParamTypeRef">
<short>Type information for parameter.</short>
</element>

<!-- variable Visibility: public -->
<element name="TProcedureSignature.ResultTypeRef">
<short>Type information for function result type.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PVmtMethodParam">
<short>Pointer to <var>TVmtMethodParam</var></short>
<descr>
<var> PVmtMethodParam</var> is a pointer to a <link id="TVmtMethodParam"/> record.
</descr>
<seealso>
<link id="TVmtMethodParam"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TVmtMethodParam">
<short>Method parameter description</short>
<descr>
<var>TVmtMethodParam</var> describes the type and location of a parameter of a method.
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TVmtMethodParam.ParamType">
<short>Reference to parameter type info.</short>
</element>

<!-- variable Visibility: public -->
<element name="TVmtMethodParam.Flags">
<short>Parameter flags</short>
</element>

<!-- variable Visibility: public -->
<element name="TVmtMethodParam.NamePtr">
<short>Pointer to parameter name.</short>
</element>

<!-- variable Visibility: public -->
<element name="TVmtMethodParam.ParaLocs">
<short>Pointer to parameter locations info</short>
</element>

<!-- property Visibility: public -->
<element name="TVmtMethodParam.Name">
<short>Parameter name</short>
<descr>
  <var>Name</var> is an ease-of-access property for the <var>NamePtr</var> field, it simply returns the name as a string.
</descr>
</element>

<!-- property Visibility: public -->
<element name="TVmtMethodParam.Tail">
<short>Pointer to location after <var>TVmtMethodParam</var> data.</short>
<descr>
<var>Tail</var> points to the memory location just after the <var>TVmtMethodParam</var> structure.
It can be used to get access to the next RTTI data, which can be again a <var>TVmtMethodParam</var> structure or another structure.
</descr>
<seealso>
<link id="TVmtMethodParam.Next"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TVmtMethodParam.Next">
<short>Pointer to the next <var>TVmtMethodParam</var> record.</short>
<descr>
<var>Next</var> is the same as <link id="TVmtMethodParam.Tail"/>, but is typed:
it returns a pointer to the next <var>TVmtMethodParam</var> record in the RTTI.
</descr>
<seealso>
<link id="TVmtMethodParam.Tail"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PIntfMethodEntry">
<short>Pointer to <var>TIntfMethodEntry</var></short>
<descr>
  <var>PIntfMethodEntry</var> is a pointer to a <link id="TIntfMethodEntry"/> record.
</descr>
<seealso>
<link id="TIntfMethodEntry"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TIntfMethodEntry">
<short>Interface method description</short>
<descr>
<var>TIntfMethodEntry</var> is a description of the RTTI generated for an <var>Interface</var> method.
This is different from class or record method RTTI info, which is described by <link id="TVmtMethodEntry"/>
</descr>
<seealso>
<link id="TVmtMethodEntry"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TIntfMethodEntry.ResultType">
<short>Typeinfo for result type</short>
</element>

<!-- variable Visibility: public -->
<element name="TIntfMethodEntry.CC">
<short>Calling convention for this method</short>
</element>

<!-- variable Visibility: public -->
<element name="TIntfMethodEntry.Kind">
<short>Method kind (procedure, function etc.)</short>
</element>

<!-- variable Visibility: public -->
<element name="TIntfMethodEntry.ParamCount">
<short>Number of parameters</short>
</element>

<!-- variable Visibility: public -->
<element name="TIntfMethodEntry.StackSize">
<short>Size of stack</short>
</element>

<!-- variable Visibility: public -->
<element name="TIntfMethodEntry.NamePtr">
<short>Pointer to  name data (a shortstring)</short>
</element>

<!-- property Visibility: public -->
<element name="TIntfMethodEntry.Name">
<short>Name of the method</short>
<descr>
<var>Name</var> dereferences the <var>NamePtr</var> field and returns the name of the method.
</descr>
<seealso>
<link id="TIntfMethodEntry.Param"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TIntfMethodEntry.Param">
<short>Indexed access to parameter descriptions</short>
<descr>
<var>Param</var> offers indexed access to the parameter descriptions.
It returns the location of the <var>Index</var>-th parameter of the method.
<var>Index</var> must be in the range 0 to <var>ParamCount-1</var> (included).
</descr>
<seealso>
<link id="TIntfMethodEntry.ResultLocs"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TIntfMethodEntry.ResultLocs">
<short>Result location descriptions</short>
<descr>
<var>ResultLocs</var> points to a record with result location descriptors:
this describes where the result(s) will be written.
</descr>
<seealso>
<link id="TParameterLocations"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TIntfMethodEntry.Tail">
<short>Pointer to location after <var>TIntfMethodEntry</var> data.</short>
<descr>
<var>Tail</var> returns a pointer to the memory location after the  <var>TIntfMethodEntry</var> data,
which can be again a <var>TIntfMethodEntry</var> record or other RTTI Data.
</descr>
<seealso>
<link id="TIntfMethodEntry.Next"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TIntfMethodEntry.Next">
<short>Pointer next <var>TIntfMethodEntry</var> entry in array.</short>
<descr>
<var>Next</var> is the same as <link id="TIntfMethodEntry.Tail"/>, but is typed:
it returns a pointer to the next <var>TIntfMethodEntry</var> record in the RTTI.
</descr>
<seealso>
<link id="TIntfMethodEntry.Tail"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PIntfMethodTable">
<short>Pointer to a <var>TIntfMethodTable</var> record.</short>
<descr>
<var>PIntfMethodTable</var> is a pointer to a <link id="TIntfMethodTable"/> record.
</descr>
<seealso>
<link id="TIntfMethodTable"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TIntfMethodTable">
<short>Interface method table</short>
<descr>
<var>TIntfMethodTable</var> is a record structure describing all the methods of an interface for which RTTI is generated.
It is basically an array of pointers <link id="TIntfMethodTable.Method"/>.
</descr>
<seealso>
<link id="TIntfMethodTable.Method"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TIntfMethodTable.Count">
<short>Number of methods</short>
</element>

<!-- variable Visibility: public -->
<element name="TIntfMethodTable.RTTICount">
<short><var>$FFFF</var> if there is no further info, or the value of Count.</short>
</element>

<!-- property Visibility: public -->
<element name="TIntfMethodTable.Method">
<short>indexed access to the methods of the interface</short>
<descr>
<var>Method</var> offers indexed access to the method descriptions.
It returns the location of the <var>Index</var>-th method of the interface
<var>Index</var> must be in the range 0 to <var>Count-1</var> (included).
</descr>
<seealso>
<link id="PIntfMethodEntry"/>
<link id="TIntfMethodEntry"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PVmtMethodEntry">
<short>Pointer to <var>TVmtMethodEntry</var> record</short>
<descr>
<var>PVmtMethodEntry</var> is a Pointer to <link id="TVmtMethodEntry"/> record.
</descr>
<seealso>
<link id="TVmtMethodEntry"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TVmtMethodEntry">
<short>Class method RTTI descriptor</short>
<descr>
<var>TVmtMethodEntry</var> is a description of the VMT info generated for a method of a <var>class</var>.
This is different from interface method RTTI info, which is described by <link id="TIntfMethodEntry"/>
</descr>
<seealso>
<link id="TIntfMethodEntry"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TVmtMethodEntry.Name">
<short>Name of the method</short>
</element>

<!-- variable Visibility: public -->
<element name="TVmtMethodEntry.CodeAddress">
<short>Pointer to the code of the method</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PVmtMethodTable">
<short>Pointer to a <var>TVmtMethodTable</var> record.</short>
<descr>
<var>PVmtMethodTable</var> is a pointer to a <link id="TVmtMethodTable"/> record.
</descr>
<seealso>
<link id="TVmtMethodTable"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TVmtMethodTable">
<short>Class methods description record</short>
<descr>
<var>TVmtMethodTable</var> is a record structure describing all the VMT methods of a class.
It is basically an array of pointers <link id="TVmtMethodTable.Entry"/>.
</descr>
<seealso>
<link id="TVmtMethodTable.Entry"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TVmtMethodTable.Count">
<short>Method count</short>
</element>

<!-- property Visibility: public -->
<element name="TVmtMethodTable.Entry">
<short>Indexed access to VMT method information</short>
<descr>
<var>Method</var> offers indexed access to the method descriptions.
It returns the location of the <var>Index</var>-th method of the VMT table
<var>Index</var> must be in the range 0 to <var>Count-1</var> (included).
</descr>
<seealso>
<link id="PVmtMethodEntry"/>
<link id="TVmtMethodEntry"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TRecOpOffsetEntry">
<short>Record initialization operator offset info</short>
<descr>
<var>TRecOpOffsetEntry</var> describes management operator info for a record.
</descr>
<seealso>
<link id="TRecOpOffsetTable"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TRecOpOffsetEntry.ManagementOperator">
<short>Pointer to management operator code</short>
</element>

<!-- variable Visibility: public -->
<element name="TRecOpOffsetEntry.FieldOffset">
<short>offset of field for which management operator is applicable</short>
</element>

<!-- record type Visibility: default -->
<element name="TRecOpOffsetTable">
<short>Management operator info for record fields.</short>
<descr>
<var>TRecOpOffsetTable</var> is a table of <link id="TRecOpOffsetEntry"/> records with management operator info for the managed fields of a record.
</descr>
<seealso>
<link id="TRecOpOffsetEntry"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TRecOpOffsetTable.Count">
<short>Count of records</short>
</element>

<!-- variable Visibility: public -->
<element name="TRecOpOffsetTable.Entries">
<short>Array of <var>TRecOpOffsetEntry</var> records</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PRecOpOffsetTable">
<short>Pointer to <var>TRecOpOffsetTable</var> record</short>
<descr>
<var>PRecOpOffsetTable</var> is a  Pointer to a <link id="TRecOpOffsetTable"/> record.
</descr>
<seealso>
<link id="TRecOpOffsetTable"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PRecInitData">
<short>Pointer to a <var>TRecInitData</var> record.</short>
<descr>
<var>PRecInitData</var> is a pointer to a <link id="TRecInitData"/> record.
</descr>
<seealso>
<link id="TRecInitData"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TRecInitData">
<short>Record intialization data</short>
<descr>
<var>TRecInitData</var> describes the generated RTTI info with which you can initialize a record that contains managed fields.
</descr>

<seealso>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TRecInitData.Terminator">
<short>?</short>
</element>

<!-- variable Visibility: public -->
<element name="TRecInitData.Size">
<short>Size (in bytes) of the record</short>
</element>

<!-- variable Visibility: public -->
<element name="TRecInitData.InitOffsetOp">
<short>Pointer to management operator data for fields.</short>
</element>

<!-- variable Visibility: public -->
<element name="TRecInitData.ManagementOp">
<short>Pointer to management operator data for this record.</short>
</element>

<!-- variable Visibility: public -->
<element name="TRecInitData.ManagedFieldCount">
<short>Number of managed fields</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PInterfaceData">
<short>Pointer to a <var>TInterfaceData</var> record.</short>
<descr>
<var>PInterfaceData</var> is a pointer to a <link id="TInterfaceData"/> record.
</descr>
<seealso>
<link id="TInterfaceData"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TInterfaceData">
<short>COM Interface RTTI descriptor</short>
<descr>
<var>TInterfaceData</var> describes the memory layout of RTTI data generated for a COM interface.
CORBA interfaces are described by  <link id="TInterfaceRawData"/>.
</descr>
<seealso>
<link id="TInterfaceRawData"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TInterfaceData.Parent">
<short>Parent interface</short>
</element>

<!-- variable Visibility: public -->
<element name="TInterfaceData.Flags">
<short>Set of interface flags.</short>
</element>

<!-- variable Visibility: public -->
<element name="TInterfaceData.GUID">
<short>GUID of this interface</short>
</element>

<!-- property Visibility: public -->
<element name="TInterfaceData.UnitName">
<short>Unit name</short>
<descr>
<var>UnitName</var>  returns the unit name in which the interface is defined.
</descr>
</element>

<!-- property Visibility: public -->
<element name="TInterfaceData.PropertyTable">
<short>Property info for this interface</short>
<descr>
<var>PropertyTable</var> returns a pointer to a table with property RTTI.
</descr>
<seealso>
<link id="TInterfaceData.MethodTable"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TInterfaceData.MethodTable">
<short>Method info for this interface</short>
<descr>
<var>MethodTable</var> returns a pointer to a table with method RTTI.
</descr>
<seealso>
<link id="TInterfaceData.PropertyTable"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PInterfaceRawData">
<short>Pointer to a <var>TInterfaceRawData</var> record.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TInterfaceRawData">
<short>COM Interface RTTI descriptor</short>
<descr>
<var>TRawInterfaceData</var> describes the memory layout of RTTI data generated for a CORBA interface.
COM interfaces are described by  <link id="TInterfaceData"/>.
</descr>
<seealso>
<link id="TInterfaceData"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TInterfaceRawData.Parent">
<short>Parent interface</short>
</element>

<!-- variable Visibility: public -->
<element name="TInterfaceRawData.Flags">
<short>Interface flags</short>
</element>

<!-- variable Visibility: public -->
<element name="TInterfaceRawData.IID">
<short>Raw GUID for this interface</short>
</element>

<!-- property Visibility: public -->
<element name="TInterfaceRawData.UnitName">
<short>Name of unit in which interface is defined.</short>
<descr>
<var>UnitName</var>  returns the unit name in which the interface is defined.
</descr>
</element>

<!-- property Visibility: public -->
<element name="TInterfaceRawData.IIDStr">
<short>GUID as string</short>
<descr>
<var>IIDStr</var> returns a string representation of <var>IID</var>.
</descr>
</element>

<!-- property Visibility: public -->
<element name="TInterfaceRawData.PropertyTable">
<short>Property info for this interface</short>
<descr>
<var>PropertyTable</var> returns a pointer to a table with property RTTI.
</descr>
<seealso>
<link id="TInterfaceRawData.MethodTable"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TInterfaceRawData.MethodTable">
<short>Method info for this interface</short>
<descr>
<var>MethodTable</var> returns a pointer to a table with method RTTI.
</descr>
<seealso>
<link id="TInterfaceRawData.PropertyTable"/>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PClassData">
<short>Pointer to a <var>TClassData</var> record.</short>
<descr>
<var>PClassData</var> is a pointer to a <link id="TClassData"/> record.
</descr>
<seealso>
<link id="TClassData"/>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TClassData">
<short>Class RTTI info record</short>
<descr>
<var>TClassData</var> describes the memory layout of RTTI data generated for a class.
</descr>
<seealso>
<link id="TInterfaceRawData"/>
<link id="TInterfaceData"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TClassData.ClassType">
<short>Class type pointer</short>
</element>

<!-- variable Visibility: public -->
<element name="TClassData.Parent">
<short>Parent class RTTI</short>
</element>

<!-- variable Visibility: public -->
<element name="TClassData.PropCount">
<short>Number of properties</short>
</element>

<!-- property Visibility: public -->
<element name="TClassData.UnitName">
<short>Name of unit in which class is implemente</short>
<descr>
<var>UnitName</var>  returns the name of the unit in which the class is implemented.
</descr>
</element>

<!-- property Visibility: public -->
<element name="TClassData.PropertyTable">
<short>Property info for this class</short>
<descr>
<var>PropertyTable</var> returns a pointer to a table with property RTTI.
</descr>
</element>

<!-- property Visibility: public -->
<element name="TTypeData.RecInitData">
<short>Pointer to record initialization data</short>
<descr>
<var>RecInitData</var> is a pointer to a <link id="TRecInitData"/> record.
It is only valid if the type data describes a record.
</descr>
<seealso>
<link id="TRecInitData"/>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TTypeData.BaseTypeRef">
<short>Pointer to RTTI of an enumerated type's base type.</short>
</element>

<!-- variable Visibility: public -->
<element name="TTypeData.SetSize">
<short>Set size in bytes</short>
</element>

<!-- variable Visibility: public -->
<element name="TTypeData.CompTypeRef">
<short>Element type reference.</short>
</element>

<!-- variable Visibility: public -->
<element name="TTypeData.ParentInfoRef">
<short>Parent class type reference.</short>
</element>

<!-- variable Visibility: public -->
<element name="TTypeData.RecInitInfo">
<short>Record initialization info </short>
</element>

<!-- variable Visibility: public -->
<element name="TTypeData.TotalFieldCount">
<short>Record field count </short>
</element>

<!-- variable Visibility: public -->
<element name="TTypeData.HelperParentRef">
<short>Reference to parent helper type info.</short>
</element>

<!-- variable Visibility: public -->
<element name="TTypeData.ExtendedInfoRef">
<short>Additional type info </short>
</element>

<!-- variable Visibility: public -->
<element name="TTypeData.IntfParentRef">
<short>Reference to parent COM interface type info</short>
</element>

<!-- variable Visibility: public -->
<element name="TTypeData.RawIntfParentRef">
<short>Reference to parent CORBA interface type info</short>
</element>

<!-- variable Visibility: public -->
<element name="TTypeData.elType2Ref">
<short>Reference to element type info</short>
</element>

<!-- variable Visibility: public -->
<element name="TTypeData.elTypeRef">
<short>Reference to element type info</short>
</element>

<!-- variable Visibility: public -->
<element name="TTypeData.InstanceTypeRef">
<short>Reference to class type info</short>
</element>

<!-- variable Visibility: public -->
<element name="TTypeData.RefTypeRef">
<short>Reference to referenced type info</short>
</element>

<!-- variable Visibility: public -->
<element name="TPropData.PropList._alignmentdummy">
<short>Alignment dummy var</short>
</element>

<!-- property Visibility: public -->
<element name="TPropData.Prop">
<short>Indexed access to property type info </short>
<descr>
<var>Prop</var> provides indexed access to the property type info of all properties of a class.
Valid values for <var>Index</var> are in the range 0..<var>WordCount-1</var>
</descr>
<seealso>
<link id="PPropInfo"/>
<link id="TPropInfo"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TPropData.Tail">
<short>Pointer to next RTTI structure.</short>
<descr>
<var>Tail</var> points to the memory area after the last property info.
It can be used to get the next RTTI info.
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: public -->
<element name="TPropInfo.PropTypeRef">
<short>Pointer to property type information</short>
</element>

<!-- property Visibility: public -->
<element name="TPropInfo.Tail">
<short>Pointer to memory location after <var>TPropInfo</var> data.</short>
<descr>
<var>Tail</var> points to the memory location right after the <var>TPropInfo</var> data.
This can be another  <var>TPropInfo</var> record, or a completely different kind of information.
</descr>
<seealso>
<link id="TPropInfo.Next"/>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TPropInfo.Next">
<short>Typed pointer <var>TPropInfo</var> record after current <var>TPropInfo</var> data.</short>
<descr>
<var>Next</var> points to the same memory location as <link id="TPropInfo.Tail"/>, but is typed.
It should not be used on the last element of a <var>TPropInfo</var> array.
</descr>
<seealso>
<link id="TPropInfo.Tail"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="AlignTypeData">
<short>Align type data</short>
<descr>
<var>AlignTypeData</var> will align the  pointer <var>p</var> on a correct boundary for
type data for the current platform  and returns the resulting address.
</descr>
<seealso>
<link id="align"/>
<link id="AlignTParamFlags"/>
<link id="AlignPTypeInfo"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="AlignTParamFlags">
<short>Align <var>TParamFlags</var> info</short>
<descr>
<var>AlignTParamFlags</var> will align the  pointer <var>p</var> on a correct boundary for
<link id="TParamFlags"/>  data for the current platform and returns the resulting address.
</descr>
<seealso>
  <link id="align"/>
  <link id="AlignTypeData"/>
  <link id="AlignPTypeInfo"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="AlignPTypeInfo">
<short>Align <var>TTypeInfo</var> info</short>
<descr>
<var>AlignPTypeInfo</var> will align the pointer <var>p</var> on a correct boundary for
<link id="TParamFlags"/>  data for the current platform  and returns the resulting address.
</descr>
<seealso>
<link id="align"/>
<link id="AlignTypeData"/>
<link id="AlignPTypeInfo"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IsReadableProp">
<short>Can the property be read</short>
<descr>
<var>IsReadableProp</var> returns <var>True</var>
if the property described by information <var>PropInfo</var> can be read, i.e. has a <var>read</var> specifier.
It returns <var>False</var> if the property can only be written.
</descr>
<seealso>
<link id="IsWriteableProp"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="IsWriteableProp">
<short>Can the property be written</short>
<descr>
<var>IsWriteableProp</var> returns <var>True</var>
if the property described by information <var>PropInfo</var> can be written to, i.e. has a <var>write</var> specifier.
It returns <var>False</var> if the property can only be read.
</descr>
<seealso>
<link id="IsReadableProp"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="GetRawbyteStrProp">
<short>Return the value of a string property as a <var>RawByteString</var></short>
<descr>
<var>GetRawbyteStrProp</var> returns the value of a string property of the object <var>Instance</var> as a <var>RawByteString</var>.
This means it has the codepage of the actual value, no codepage translation is done.
The property to read can be specified using the name <var>PropName</var> or the property info <var>PropInfo</var>.
</descr>
<seealso>
<link id="GetStrProp"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetRawByteStrProp">
<short>Set the value of a string property using a <var>RawByteString</var></short>
<descr>
<var>GetRawbyteStrProp</var> writes the value of a string property of the object <var>Instance</var> to <var>Value</var>, a <var>RawByteString</var>.
This means  no codepage translation is done.
The property to write can be specified using the name <var>PropName</var> or the property info <var>PropInfo</var>.
</descr>
<seealso>
<link id="SetStrProp"/>
<link id="GetRawByteStrProp"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="GetDynArrayProp">
<short>Get the value of a dynamic array valued property</short>
<descr>
<var>GetDynArrayProp</var> returns the value of a dynamic array valued property of the object <var>Instance</var> as a pointer.
The property to read can be specified using the name <var>PropName</var> or the property info <var>PropInfo</var>.
</descr>
<seealso>
<link id="SetDynArrayProp"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="SetDynArrayProp">
<short>SetSize the value of a dynamic array valued property</short>
<descr>
<var>GetDynArrayProp</var> returns the value of a dynamic array valued property of the object <var>Instance</var> to the pointer <var>Value</var>.
The property to read can be specified using the name <var>PropName</var> or the property info <var>PropInfo</var>.
</descr>
<seealso>
<link id="GetDynArrayProp"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="AddEnumElementAliases">
<short>Define aliases for enumerated elements</short>
<descr>
<p>
<var> AddEnumElementAliases</var> defines aliases for enumerated values of type <var>aTypeInfo</var>.
The aliases are specified in <var>aNames</var>, and are applied as of the element with ordinal value <var>aStartIndex</var>.
</p>
<p>
  The aliases will be used in <link id="GetEnumValue"/>
</p>
</descr>
<seealso>
<link id="RemoveEnumElementAliases"/>
<link id="GetEnumValue"/>
<link id="GetEnumeratedAliasValue"/>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="RemoveEnumElementAliases">
<short>Remove aliases for enumerated elements.</short>
<descr>
<var>RemoveEnumElementAliases</var> removes all aliases for enumerated type <var>aTypeInfo</var>.
The aliases must have been defined using <link id="AddEnumElementAliases"/>.
</descr>
<errors>
<link id="AddEnumElementAliases"/>
<link id="GetEnumValue"/>
<link id="GetEnumeratedAliasValue"/>
</errors>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="GetEnumeratedAliasValue">
<short>Return ordinal value for an enumerated value</short>
<descr>
<var>GetEnumeratedAliasValue</var> will return the ordinal value of the alias
<var>aName</var> for type <var> aTypeInfo</var>.
</descr>
<seealso>
<link id="AddEnumElementAliases"/>
<link id="RemoveEnumElementAliases"/>
<link id="GetEnumValue"/>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="DerefTypeInfoPtr">
<short>Dereference type info pointer</short>
<descr>
<var>DerefTypeInfoPtr</var> can be used to dereference the <var>Info</var> type info pointer if need be:
in FPC version 3.0, this pointer does not need dereferencing, but in FPC version 3.1, the pointer must be dereferenced.
This is useful for code that must work in version 3.0 and later.
</descr>
<errors>
The function handles nil values well.  
</errors>
<seealso>
<link id="PTypeInfo"/>
</seealso>
</element>

</module>
</package>
</fpdoc-descriptions>
